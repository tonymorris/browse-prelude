  (-) :: a -> a -> a
  (/) :: a -> a -> a
  (*) :: a -> a -> a
  (**) :: a -> a -> a
  (+) :: a -> a -> a
(++) :: [a] -> [a] -> [a]
  (<=) :: a -> a -> Bool
  (<) :: a -> a -> Bool
  (==) :: a -> a -> Bool
  (>=) :: a -> a -> Bool
  (>) :: a -> a -> Bool
  (/=) :: a -> a -> Bool
($!) :: (a -> b) -> a -> b
($) :: (a -> b) -> a -> b
  abs :: a -> a
  acos :: a -> a
  acosh :: a -> a
  (<$) :: a -> f b -> f a
(!!) :: [a] -> Int -> a
all :: Foldable t => (a -> Bool) -> t a -> Bool
and :: Foldable t => t Bool -> Bool
any :: Foldable t => (a -> Bool) -> t a -> Bool
appendFile :: FilePath -> String -> IO ()
  asin :: a -> a
  asinh :: a -> a
asTypeOf :: a -> a -> a
  atan2 :: a -> a -> a
  atan :: a -> a
  atanh :: a -> a
(.) :: (b -> c) -> (a -> b) -> a -> c
(||) :: Bool -> Bool -> Bool
(&&) :: Bool -> Bool -> Bool
break :: (a -> Bool) -> [a] -> ([a], [a])
  ceiling :: Integral b => a -> b
class Applicative m => Monad (m :: * -> *) where
class Bounded a where
class Enum a where
class Eq a => Ord a where
class Eq a where
class Foldable (t :: * -> *) where
class Fractional a => Floating a where
class Functor f => Applicative (f :: * -> *) where
class Functor (f :: * -> *) where
class (Functor t, Foldable t) => Traversable (t :: * -> *) where
class Monoid a where
class Num a => Fractional a where
class (Num a, Ord a) => Real a where
class Num a where
class Read a where
class (Real a, Enum a) => Integral a where
class (Real a, Fractional a) => RealFrac a where
class (RealFrac a, Floating a) => RealFloat a where
class Show a where
  compare :: a -> a -> Ordering
concat :: Foldable t => t [a] -> [a]
concatMap :: Foldable t => (a -> [b]) -> t a -> [b]
const :: a -> b -> a
  cos :: a -> a
  cosh :: a -> a
curry :: ((a, b) -> c) -> a -> b -> c
cycle :: [a] -> [a]
data Bool = False | True
data Char = GHC.Types.C# GHC.Prim.Char#
data Double = GHC.Types.D# GHC.Prim.Double#
data Either a b = Left a | Right b
data Float = GHC.Types.F# GHC.Prim.Float#
  Data.Foldable.foldl' :: (b -> a -> b) -> b -> t a -> b
  Data.Foldable.fold :: Monoid m => t m -> m
  Data.Foldable.foldr' :: (a -> b -> b) -> b -> t a -> b
  Data.Foldable.toList :: t a -> [a]
data Integer
data Int = GHC.Types.I# GHC.Prim.Int#
data Maybe a = Nothing | Just a
data Ordering = LT | EQ | GT
data Word = GHC.Types.W# GHC.Prim.Word#
  decodeFloat :: a -> (Integer, Int)
  div :: a -> a -> a
  divMod :: a -> a -> (a, a)
drop :: Int -> [a] -> [a]
dropWhile :: (a -> Bool) -> [a] -> [a]
either :: (a -> c) -> (b -> c) -> Either a b -> c
  elem :: Eq a => a -> t a -> Bool
  encodeFloat :: Integer -> Int -> a
  enumFrom :: a -> [a]
  enumFromThen :: a -> a -> [a]
  enumFromThenTo :: a -> a -> a -> [a]
  enumFromTo :: a -> a -> [a]
error :: [Char] -> a
even :: Integral a => a -> Bool
  exp :: a -> a
  exponent :: a -> Int
  (<*>) :: f (a -> b) -> f a -> f b
  (<*) :: f a -> f b -> f a
  (*>) :: f a -> f b -> f b
  fail :: String -> m a
filter :: (a -> Bool) -> [a] -> [a]
flip :: (a -> b -> c) -> b -> a -> c
  floatDigits :: a -> Int
  floatRadix :: a -> Integer
  floatRange :: a -> (Int, Int)
  floor :: Integral b => a -> b
  fmap :: (a -> b) -> f a -> f b
  foldl1 :: (a -> a -> a) -> t a -> a
  foldl :: (b -> a -> b) -> b -> t a -> b
  foldMap :: Monoid m => (a -> m) -> t a -> m
  foldr1 :: (a -> a -> a) -> t a -> a
  foldr :: (a -> b -> b) -> b -> t a -> b
(^^) :: (Fractional a, Integral b) => a -> b -> a
  fromEnum :: a -> Int
  fromInteger :: Integer -> a
fromIntegral :: (Integral a, Num b) => a -> b
  fromRational :: Rational -> a
fst :: (a, b) -> a
(<$>) :: Functor f => (a -> b) -> f a -> f b
gcd :: Integral a => a -> a -> a
getChar :: IO Char
getContents :: IO String
getLine :: IO String
                  -> (# GHC.Prim.State# GHC.Prim.RealWorld, a #))
  GHC.Read.readListPrec ::
  GHC.Read.readPrec :: Text.ParserCombinators.ReadPrec.ReadPrec a
  = GHC.Types.IO (GHC.Prim.State# GHC.Prim.RealWorld
head :: [a] -> a
id :: a -> a
init :: [a] -> [a]
  | integer-gmp-1.0.0.0:GHC.Integer.Type.Jn# {-# UNPACK #-}integer-gmp-1.0.0.0:GHC.Integer.Type.BigNat
  | integer-gmp-1.0.0.0:GHC.Integer.Type.Jp# {-# UNPACK #-}integer-gmp-1.0.0.0:GHC.Integer.Type.BigNat
  = integer-gmp-1.0.0.0:GHC.Integer.Type.S# !GHC.Prim.Int#
interact :: (String -> String) -> IO ()
ioError :: IOError -> IO a
  isDenormalized :: a -> Bool
  isIEEE :: a -> Bool
  isInfinite :: a -> Bool
  isNaN :: a -> Bool
  isNegativeZero :: a -> Bool
iterate :: (a -> a) -> a -> [a]
last :: [a] -> a
lcm :: Integral a => a -> a -> a
  length :: t a -> Int
lex :: ReadS String
lines :: String -> [String]
  log :: a -> a
  logBase :: a -> a -> a
lookup :: Eq a => a -> [(a, b)] -> Maybe b
  (>>=) :: m a -> (a -> m b) -> m b
  (>>) :: m a -> m b -> m b
map :: (a -> b) -> [a] -> [b]
mapM_ :: (Foldable t, Monad m) => (a -> m b) -> t a -> m ()
  mapM :: Monad m => (a -> m b) -> t a -> m (t b)
  mappend :: a -> a -> a
  max :: a -> a -> a
  maxBound :: a
  maximum :: Ord a => t a -> a
maybe :: b -> (a -> b) -> Maybe a -> b
  mconcat :: [a] -> a
  mempty :: a
  min :: a -> a -> a
  minBound :: a
  minimum :: Ord a => t a -> a
  mod :: a -> a -> a
(=<<) :: Monad m => (a -> m b) -> m a -> m b
  negate :: a -> a
newtype IO a
not :: Bool -> Bool
notElem :: (Foldable t, Eq a) => a -> t a -> Bool
  null :: t a -> Bool
(^) :: (Num a, Integral b) => a -> b -> a
odd :: Integral a => a -> Bool
or :: Foldable t => t Bool -> Bool
otherwise :: Bool
  pi :: a
  pred :: a -> a
print :: Show a => a -> IO ()
  product :: Num a => t a -> a
  properFraction :: Integral b => a -> (b, a)
  pure :: a -> f a
putChar :: Char -> IO ()
putStrLn :: String -> IO ()
putStr :: String -> IO ()
  quot :: a -> a -> a
  quotRem :: a -> a -> (a, a)
readFile :: FilePath -> IO String
readIO :: Read a => String -> IO a
  readList :: ReadS [a]
readLn :: Read a => IO a
readParen :: Bool -> ReadS a -> ReadS a
read :: Read a => String -> a
  readsPrec :: Int -> ReadS a
reads :: Read a => ReadS a
realToFrac :: (Real a, Fractional b) => a -> b
  recip :: a -> a
  rem :: a -> a -> a
repeat :: a -> [a]
replicate :: Int -> a -> [a]
  return :: a -> m a
reverse :: [a] -> [a]
  round :: Integral b => a -> b
  scaleFloat :: Int -> a -> a
scanl1 :: (a -> a -> a) -> [a] -> [a]
scanl :: (b -> a -> b) -> b -> [a] -> [b]
scanr1 :: (a -> a -> a) -> [a] -> [a]
scanr :: (a -> b -> b) -> b -> [a] -> [b]
seq :: a -> b -> b
  sequenceA :: Applicative f => t (f a) -> f (t a)
sequence_ :: (Foldable t, Monad m) => t (m a) -> m ()
  sequence :: Monad m => t (m a) -> m (t a)
  show :: a -> String
showChar :: Char -> ShowS
  showList :: [a] -> ShowS
showParen :: Bool -> ShowS -> ShowS
  showsPrec :: Int -> a -> ShowS
shows :: Show a => a -> ShowS
showString :: String -> ShowS
  significand :: a -> a
  signum :: a -> a
  sin :: a -> a
  sinh :: a -> a
snd :: (a, b) -> b
span :: (a -> Bool) -> [a] -> ([a], [a])
splitAt :: Int -> [a] -> ([a], [a])
  sqrt :: a -> a
subtract :: Num a => a -> a -> a
  succ :: a -> a
  sum :: Num a => t a -> a
tail :: [a] -> [a]
take :: Int -> [a] -> [a]
takeWhile :: (a -> Bool) -> [a] -> [a]
  tan :: a -> a
  tanh :: a -> a
    Text.ParserCombinators.ReadPrec.ReadPrec [a]
  toEnum :: Int -> a
  toInteger :: a -> Integer
  toRational :: a -> Rational
  traverse :: Applicative f => (a -> f b) -> t a -> f (t b)
  truncate :: Integral b => a -> b
type FilePath = String
type IOError = GHC.IO.Exception.IOException
type Rational = GHC.Real.Ratio Integer
type ReadS a = String -> [(a, String)]
type ShowS = String -> String
type String = [Char]
uncurry :: (a -> b -> c) -> (a, b) -> c
undefined :: a
unlines :: [String] -> String
until :: (a -> Bool) -> (a -> a) -> a -> a
unwords :: [String] -> String
unzip3 :: [(a, b, c)] -> ([a], [b], [c])
unzip :: [(a, b)] -> ([a], [b])
userError :: String -> IOError
words :: String -> [String]
writeFile :: FilePath -> String -> IO ()
zip3 :: [a] -> [b] -> [c] -> [(a, b, c)]
zip :: [a] -> [b] -> [(a, b)]
zipWith3 :: (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]
zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
